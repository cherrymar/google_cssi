
## Getting Started
After you  have cloned this lab, make sure you install the requirements
`pip install -r requirements.txt`

## Part 1 - Routes, Handlers and Responses
To start with, let's make sure we can appropriately handle requests to various routes. While your app will have the same base url (`'www.myapp.com'`), you will want your app to load different responses based on the request(`'www.myapp.com/predict'` vs `'www.myapp.com/goodbye'`). We will practice making requests to various routes and exploring our app's response. Remember, a get request simply means that a user has entered a certain url into a browser.
* A. Before working on any app, make sure it's running by typing `dev_appserver.py app.yaml` into the terminal. You should see the response that is generated by the Hello Handler.
* B. In your browser, change the url to `'localhost:8080/predict'`. When you click enter, a request is made to the route (`'/predict'`), and you will see 'a response from the FortuneHandler'.
* C. Create a new handler, GoodbyeHandler, that has a response of "My response is Goodbye World". On the bottom of main.py, add a new route mapping so that a get request to ('/farewell') calls the GoodbyeHandler.


## Part 2 - Changing the Fortune Handler Response
Now that you've practiced using and adding handlers and mapping routes for them, it's time to start building a fortune teller app.  First, you will use your existing Python knowledge to write the code to  display a random fortune in the browser each time the FortuneHandler is called. This response should be written under the get(self) method, so that it is called anytime a user accesses the '/predict' url. (`localhost:8080/predict`).
* A. Complete the method `get_fortune()` so that it returns a random fortune from the list of hardcoded fortunes. This doesn't require any GAE knowledge, you're simply generating a function with zero arguments and a string output.
* B. In the `get(self)` method of the FortuneHandler, use the get_fortune() method from part A  to return a random fortune. Use webapp2's `self.response.write()` method to actually display the fortune.
* C. Launch your app by opening up the terminal and using the `dev_appserver.py` command with the appropriate file (See Part 1 for the full command). Refresh the page a few times to ensure you are seeing random fortunes each time the page is loaded. *[**Hint:** you can use the up arrow in the terminal to scroll through and use previous commands]*

## Part 3 - Templating and Static Files
You app responds to a get request to the root url(/) by writing a string message. In order for the response to be a full HTML page in Google App Engine you need to add Jinja2 templating. This will allow your app to be dynamic, meaning each HTML page can change as the user interacts with the app.
* A. Create a simple html page, `fortune-results.html`. This page should include the <head> and <body> elements, with a header and paragraph in the <body>. Save this in a new directory called `templates`.
* B. In order to render this html page as a template (an interactive page), add jinja2 to your app. Remember, you will need to import it as a library and also add it to the app.yaml file.
* C. In order for jinja2 to access your local files to get the templates, you need to set up an environment variable. Do this by pasting the jinja2 environment variable as the value for `jinja_current_directory`, which is currently set to a string. The jinja2 environment variable can be found in Google App Engine documentation or in the CSSI notes.
* D. In the `get(self)` method of FortuneHandler, create a new variable, results_template with the value of the results HTML page you created in part A. Then, write that as part of the request by using the .render() method inside of the response.
* E. Launch your app to make sure that your simple HTML page is being rendered with the request to the root route.

## Part 4 - Forms, the POST Method, Template Variables
Your app is not actually an app yet. Any request to the app, just renders the same static page. In order to make your fortune teller interesting, you need to add a place for the user to provide some new information. This means adding a form that the user sees during the get method (when then first get to a certain url) and then a results page that they see on the post method (after they add their own data and submit it using a form).

Your app will take a user's astrological sign, and come up with a fortune for them. While your code won't actually use the astrological sign to predict the fortune, you will still get to use that piece of information in the results page.

* A. Create a new template, fortune-start.html, which has a header and form in the body. The form should contain a `<select>` element with all of the possible astrological signs. Be sure your form's method attribute is set to ``"post"`` so that it can send the data to the controller.

```
<select name="user_astrological_sign">
  <option value="Aquarius">Aquarius</option>
  <option value="Pisces">Pisces</option>
  <option value="Aires">Aires</option>
  <option value="Taurus">Taurus</option>
  <option value="Gemini">Gemini</option>
  <option value="Cancer">Cancer</option>
  <option value="Leo">Leo</option>
  <option value="Virgo">Virgo</option>
  <option value="Libra">Libra</option>
  <option value="Scorpio">Scorpio</option>
  <option value="Sagittarius">Sagittarius</option>
  <option value="Capricorn">Capricorn</option>
</select>
```
* B. Next it's time to access the data from the form. Create a new variable `user_astro_sign` that has the value from the `<select>` input. You will need to use webapp2's `self.request.get` method.
* C. Now that you have the user's astrological sign stored in the variable `user_astro_sign`, pass it to the results template as part of a dictionary. You'll also want to add the random fortune to the dictionary so that it gets passed to the results template too. In the post(self) method of the FortuneHandler, you can pass the dictionary to the results template by using `self.response.write(end_template.render(my_dict))` where end_template is a variable that contains the path of the results template. (See 2C for help)
* D. Finally, in order to get your two pieces of data to be shown in the results template, use jinja2's mustaches `{{}}` to wrap around the **keys** of the template variable dictionary. These mustaches should be used in the results template.
